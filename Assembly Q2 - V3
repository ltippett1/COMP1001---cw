
; A simple example adding two numbers.
.386  ; Specify instruction set
.model flat, stdcall  ; Flat memory model, std. calling convention
.stack 4096 ; Reserve stack space
ExitProcess PROTO, dwExitCode: DWORD  ; Exit process prototype


.data ; data segment

; define your variables here

    arrayA DWORD 3, 2, 3, 1, 7, 5, 0, 8, 9, 2 ; this is the array for A
    arrayB DWORD ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ; this is the array for B and we put ? as we don't know the values 
    arrayC DWORD 1, 3, 2, 5, 4, 6, 0, 4, 5, 8 ; this is the array for C



    

.code ; code segment


main PROC ; main procedure

; write your assembly code here

    mov ebx, 2 ; this will store the value 2
    mov esi, 0 ; this is for the index
    mov edi, 1 ; this will store the value 1 into edi
    mov ebp, 3 ; this will store the value 3 into ebp

update: ; this is the loop for arrayA
; First part
    mov eax, [arrayA + TYPE arrayA * esi] ; will use the index esi to load the required value
    mul ebx ; this will multiply the value by 2
    add edi ; this will now add 1 to the value
; Second part
    mov ecx, [arrayC + TYPE arrayC * esi]
    mul ebp ; this will multiply the value by 3
    add edi
; Third part
    mov eax, [arrayA + TYPE arrayA * esi]
    mov ecx, [arrayC + TYPE arrayC * esi]
    add eax, ecx ; this will add the values of the arrays together 
    div ebp ; this will then divide the sum by 3

; Storing in B
    add edx, eax ; this will add the sum of the loop to edx
    mov [arrayB + TYPE arrayB * esi], edx ; this will store the values into B
    inc esi ; this will increment esi by 1 each time 
    cmp esi, 9 ; compare to see if we have used all the indicies to make sure we change all 10 values
    jne update ; this will start the loop again if all the indicies have not been used



    INVOKE ExitProcess, 0 ; call exit function

main ENDP ; exit main procedure
END main  ; stop assembling 
