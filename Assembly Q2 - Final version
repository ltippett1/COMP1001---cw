
; A simple example adding two numbers.
.386  ; Specify instruction set
.model flat, stdcall  ; Flat memory model, std. calling convention
.stack 4096 ; Reserve stack space
ExitProcess PROTO, dwExitCode: DWORD  ; Exit process prototype


.data ; data segment

; define your variables here

    arrayA DWORD 3, 2, 3, 1, 7, 5, 0, 8, 9, 2 ; this is the array for A
    arrayB DWORD ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ; this is the array for B and we put ? as we don't know the values 
    arrayC DWORD 1, 3, 2, 5, 4, 6, 0, 4, 5, 8 ; this is the array for C

.code ; code segment


main PROC ; main procedure

; write your assembly code here

    mov ebx, 2 ; this will store the value 2
    mov esi, 0 ; this is for the index
    mov edi, 1 ; this will store the value 1 into edi
    mov ebp, 3 ; this will store the value 3 into ebp

update: 
; First part
    mov eax, [arrayA + TYPE arrayA * esi] ; will use the index esi to load the required value
    mov edx, 0 ; to make sure it starts as 0 for each loop cycle to avoid a chance of errors
    mul ebx ; this will multiply the value by 2
    add eax, edi ; this will now add 1 to the value
    mov ecx, eax ; store value in ecx


; Second part
    mov ecx, [arrayC + TYPE arrayC * esi]
    mov edx, 0
    mul ebp ; this will multiply the value by 3
    add eax, edi
    add ecx, eax ; this will add the new value to ecx

; Third part
    mov eax, [arrayA + TYPE arrayA * esi]
    mov ecx, [arrayC + TYPE arrayC * esi]
    add eax, ecx ; this will add the values of the arrays together 
    mov edx, 0
    div ebp ; this will then divide the sum by 3
    add ecx, eax ; this will add the new value to ecx

; Storing in B
    mov [arrayB + TYPE arrayB * esi], ecx ; this will store the values into B

    inc esi ; this will increment esi by 1 each time 
    cmp esi, 10 ; compare to see if we have used all the indicies to make sure we change all 10 values
    jne update ; this will start the loop again if all the indicies have not been used



    INVOKE ExitProcess, 0 ; call exit function

main ENDP ; exit main procedure
END main  ; stop assembling 
